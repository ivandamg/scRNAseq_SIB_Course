---
title: "single_cell_course_sib"
author: "IM"
date: "11/8/2021"
output: pdf_document
---

```{r setup, include=FALSE}
library(Seurat)
library(ggplot2)
library(scater)
library(SingleCellExperiment)
library(Seurat)
library(clustree)
library(celldex)
library(SingleR)
```

## SIB course
#https://sib-swiss.github.io/single-cell-training/2021.11/day1/introduction_scrnaseq/



We will work on the GBM dataset that is:  Transcriptomes of human glioblastoma multiforme cells, generated by 10x genomics. This will be our most used dataset, we will use it throughout the course. Source: 10x datasets

We will analyse one sample

## Day1 Seurat typical analysis

We will analyse differentially expressed genes within the same sample. Different cells. 


We start the analysis from the output made by the Illumina sequencing of the 10x libraries?.  First step is to produce the three files by using cellranger pipeline

use filtered matrix


Empty droplets are needed to control for ambient RNA. 

Load data with seurat package

show firt 30 cells of 3 genes. we noticed allot of empty spaces.
```{r load_data}
# load 10x data with Seurat package

gbm.data <- Seurat::Read10X(data.dir = "C://Users/imateusg/Documents/WW_courses/02_SingleCELL_SIB2021/single_cell_course/data/gbm_dataset/filtered_feature_bc_matrix/")

gbm.data[c("PECAM1", "CD8A", "TSPAN1"), 1:30]
```

Generate Seurat Object including only genes that contain at least 3 cell and that expression is detected for more than 100 genes
```{r create_seurat_object}
gbm <- Seurat::CreateSeuratObject(counts = gbm.data,
                                  project = "gbm",
                                  min.cells = 3,
                                  min.features = 100)
gbm

```

We found that the Run contained 24363 different features across 5553 cells 

Inspect gbm@meta.data object. we have two columns. nCount which defines total number of counts, and nFeature which define total number of genes.

```{r create_hist counts}
head(gbm@meta.data)
ggplot(gbm@meta.data, aes(x=nCount_RNA)) + geom_histogram() + labs( title="Histogram of total count per cell")
```
or you can plot how the two variables correlate via Seurat
```{r create_scatter feature counts}
Seurat::FeatureScatter(gbm, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")

```

# Basic Quality Control
A high number of UMIs originating from mitochondrial genes can point to dying cells. In order to calculate the percentage of UMIs coming from mitochondrial genes for each cell, we use the function PercentageFeatureSet. In our count matrix, the names of mitochondrial genes all start with MT-, so we can use that pattern to search these genes:

We should define thresholds min genes, counts mitochondria based on different thresholds, that could be dataset specific.do not use the same thresholds as other papers. Each dataset should have its own thresholds.
A way to make this more reproducible, it could be to make permutations of different thresholds and choose the thresholds that produce similar results.

```{r QC, echo=FALSE}
# Include in the gbm object a column with percentage of mitochondrial genes 
gbm[["percent.mt"]] <- Seurat::PercentageFeatureSet(gbm, pattern = "^MT-")
head(gbm@meta.data)
# distribution of the three features counts, features and mitochondrial genes
Seurat::VlnPlot(gbm, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# there is a correlation between the nb of UMI and percentage of mictochondrial genes that can be plotted 
Seurat::FeatureScatter(gbm, feature1 = "nCount_RNA", feature2 = "percent.mt")

# this can be found for nFeatures as well
Seurat::FeatureScatter(gbm, feature1 = "nFeature_RNA", feature2 = "percent.mt")

# Based on the figures, we could filter out all the cells that display between 500 and 7500 features and which less than 20% of the UMI come from mitochondrial genes
gbm <- subset(gbm,
              subset = nFeature_RNA > 500 & nFeature_RNA < 7500 & percent.mt < 20)
# lets find how many cells where filtered out
dim(gbm)
```

We found that 5553-5091(462) cells where filtered out


## Normalization

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in the “RNA” slot of the gbm object.

```{r Normalization, echo=FALSE}
gbm <- Seurat::NormalizeData(gbm,
                     normalization.method = "LogNormalize",
                     scale.factor = 10000)
```
## Variable features

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, and is implemented in the FindVariableFeatures() function. By default, 2,000 genes (features) per dataset are returned and these will be used in downstream analysis, like PCA.

```{r Variable features, echo=FALSE}
gbm <- Seurat::FindVariableFeatures(gbm,
                            selection.method = "vst",
                            nfeatures = 2000)
# lets see the top 10 genes
top10 <- head(Seurat::VariableFeatures(gbm), 10)
top10
# plot the first 10 
vf_plot <- Seurat::VariableFeaturePlot(gbm)
Seurat::LabelPoints(plot = vf_plot,
            points = top10, repel = TRUE)

```

## Scaling

Next, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The ScaleData() function

    shifts the expression of each gene, so that the mean expression across cells is 0
    scales the expression of each gene, so that the variance across cells is 1

This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate. The results of this are stored in gbm$RNA@scale.data This also can be done with Seurat::SCTransform


```{r Scaling, echo=FALSE}
gbm <- Seurat::ScaleData(gbm,
                 features = rownames(gbm))

gbm$RNA@scale.data[1:5,1:10]

```

## Quality control

In this part we will use package seurat to learn about: 

1. Assign cell cycle phases to a single cell dataset
2. Use the package scater evaluate cell quality based on reads originating from:
        mitochondrial genes
        ribosomal genes
        dissociation-related genes
3. Evaluate confounding effects on expression data by analyzing the explained variance


# Cell cycle analysis

Cells could be captured in different cycle phases. From human cells, we know from databases, that some genes are expressed in different cell cycles. 

Seurat::cc.genes.updated.2019 contains genes classified by cell cycle we will add this info to the gbm3 dataset

We can visualize the distribution of cell cycle markers (genes characteristic from a cell cycle)
```{r cell cycle}
s.genes <- Seurat::cc.genes.updated.2019$s.genes
g2m.genes <- Seurat::cc.genes.updated.2019$g2m.genes

gbm <- Seurat::CellCycleScoring(gbm,
                                s.features = s.genes,
                                g2m.features = g2m.genes)
table(gbm$Phase)
#
Seurat::RidgePlot(gbm, features = c("PCNA", "MKI67"),
          group.by = "Phase",
          ncol = 2)
```

# Quality control with Scater

Scater includes different types of quality controls:
    QC and filtering of cells
    QC and filtering of features (genes)
    QC of experimental variables

the scater package as well as other bioconductor packages, rely on an object of the class SingleCellExperiment. So first we get the counts with Seurat. Then we use the function SingleCellExperient to import the cts and metadata

```{r QC scatter counts}
cts <- Seurat::GetAssayData(gbm, slot = "counts")
gbm_sce <- SingleCellExperiment::SingleCellExperiment(
  assays = list(counts = cts),
  colData = gbm@meta.data,
  rowData = rownames(gbm)
)
```

We can now find variables in the data set that can be used as explanatory variables. These variables can explain a lot of the variance observed in the cells.


We can import info about mitochondrial gene expression. But we can also run a quality check on stressed cells. Genes related to stress are known and could cluster together as a false type of cell. This step is known as dissociation protocol-related gene expression. and are available in data/dissocation_genes.txt

We then compute the info about each type to the summarized experiment. We work now with Scuttle package
```{r QC scuttle}
dissoc_genes <- readLines("C://Users/imateusg/Documents/WW_courses/02_SingleCELL_SIB2021/single_cell_course/data/gbm_dataset/dissocation_genes.txt")
ribo_genes <- rownames(gbm)[grep(pattern = "^RP[S|L]", rownames(gbm), perl = T)]
mito_genes <- rownames(gbm)[grep(pattern = "^MT-", rownames(gbm))]
# 
gbm_sce <- scuttle::addPerCellQC(gbm_sce,
                        subsets=list(mito_genes=which(rownames(gbm_sce) %in% mito_genes),
                                     dissoc_genes=which(rownames(gbm_sce) %in% dissoc_genes),
                                     ribo_genes=which(rownames(gbm_sce) %in% ribo_genes)))
#  compute a number of quality control metrics for each cell and feature (i.e gene)
SingleCellExperiment::colData(gbm_sce)

# Rarefaction curve
scater::plotColData(gbm_sce, x = "sum", y="detected")
#percentage of mitochondrial genes
scater::plotColData(gbm_sce, x = "detected", y="subsets_mito_genes_percent")
#percentage dissociation genes
scater::plotColData(gbm_sce, x = "detected", y="subsets_dissoc_genes_percent")
#correlation mitochondrial genes and ribo genes
scater::plotColData(gbm_sce, x = "subsets_mito_genes_percent", y="subsets_ribo_genes_percent")

```



# Highly expressed genes

Identification of highly expressed genes. these are the ones that we want to get rid off.

On the gene level, we can look at a plot that shows the top (by default 50) most-expressed genes. Each row in the plot corresponds to a gene; each bar corresponds to the expression of a gene in a single cell; and the circle indicates the median expression of each gene, with which genes are sorted. We expect to see the “usual suspects”, i.e., mitochondrial genes, actin, ribosomal protein, MALAT1. If used, few spike-in transcripts may also be present here, though if all of the spike-ins are in the top 50, it suggests that too much spike-in RNA was added. A large number of pseudo-genes or predicted genes may indicate problems with alignment.

visualize high expressed genes 

```{r highly expressed }
scater::plotHighestExprs(gbm_sce, exprs_values = "counts", n = 30)

```


# Find explanatory variables



Variable-level metrics are computed by the getVarianceExplained() function (after normalization, see below). This calculates the percentage of variance of each gene’s expression that is explained by each variable in the colData of the SingleCellExperiment object. We can then use this to determine which experimental factors are contributing most to the variance in expression. This is useful for diagnosing batch effects or to quickly verify that a treatment has an effect.

First, computing variance explained on the log-counts, so that the statistics reflect changes in relative expression.

```{r normalization}
gbm_sce <- scater::logNormCounts(gbm_sce)  # alternative to Seurat's normalization here using scater

```

In the gbm dataset, we only have 1 patient, so we cannot calculate the effect of experimental variables like sex or donor id, but in case we would have several variables, here is the method with the cell cycle phase as example:
Look at the percentage of variance explained by phase or detected expression.

Variance due to the cell type (Detected)


```{r explanataory vars2 }
vars <- scater::getVarianceExplained(gbm_sce,
                             variables = c("detected","Phase") )
head(vars) # show how each variable is  explained for each gene 
scater::plotExplanatoryVariables(vars)
```


A distribution of percentage variance explained by each gene is shown, and can indicate whether one or the other experimental variable has high contribution to the variance in the data:

The cell cycle explain around 1% of variance so it should be interesting to take this into account.


If we think that the cell cycling has an effect on the analysis, and if we want to regress out this effect so that cycling cells are integrated into the rest of the cells and not clustering apart anymore, we can regress out the cell cycling phase at the moment of scaling the data using ScaleData. This might be slow to compute.


# do not run
```{r regress variables }
#gbm_cc <- Seurat::ScaleData(gbm, vars.to.regress = c("S.Score", "G2M.Score"))

```
save work with RDS file
```{r save }
#saveRDS(gbm, "C://Users/imateusg/Documents/WW_courses/02_SingleCELL_SIB2021/gbm_day1.rds")

```


## Day 2 . Dimensionality reduction

Once the data is normalized, scaled and variable features have been identified, we can start to reduce the dimensionality of the data. For the PCA, by default, only the previously determined variable features are used as input, but can be defined using features argument if you wish to specify a vector of genes. The PCA will only be run on the variable features, that you can check with VariableFeatures(gbm).

open work space with RDS file
```{r open }
#openRDS(gbm, "C://Users/imateusg/Documents/WW_courses/02_SingleCELL_SIB2021/gbm_day1.rds")

```


Perform a pca
```{r pca }
gbm <- Seurat::RunPCA(gbm)
Seurat::DimPlot(gbm, reduction = "pca")
# With colors
Seurat::DimPlot(gbm, reduction = "pca", group.by = "Phase")
```

Coming back to the cell cycle analysis, we can check the distribution of the different cell cycle phases over the PCA, and eventually regress it out using the ScaleData() function. But here, the PCA doesn’t seem to cluster according to the cell cycle phase. Which is concordant with the less than 1% of variability due to the cell cycle. In consequence, we do not need to regress this variable.

We can see how foe each axis of the PCA the cells correlates to each other.
```{r Dimheatmap }
Seurat::DimHeatmap(gbm, dims = 1:12, cells = 500, balanced = TRUE)

```

The elblow plot can help to determine how many PCA axis to use in downstream analysis.
```{r Elblowplot }
Seurat::ElbowPlot(gbm, ndims = 40)
# we can check the percentage of variance of each PCA axis by using 
test <-Seurat::ElbowPlot(gbm, ndims = 40)
test$data$stdev/sum(test$data$stdev)
```


The elblow plot ranks principle components based on the percentage of variance explained by each one. Where we observe an “elblow” or flattening curve, the majority of true signal is captured by this number of PCs, eg around 25 PCs for the gbm dataset.



Dimentionality reduction with PCA:
PCA doesn’t fit for single cell data because
• It is a LINEAR method of dimensionalityreduction
• It is an interpretable dimensionality reduction
• Data is usually SCALEDprior to PCA (Z-score | see ScaleData in the Seurat)
• The TOPprincipal components contain higher variance from the data
• Can be used as FILTERING,by selecting only the top significant PCs
• PCs that explain at least 1%of variance
• Jackstraw of significantp-values
• The first 5-10 PCs
• Scater library describes correlation between PCs and metadata, take PCs until
metadata information is covered


The Problems:
• The two first PC in SC-RNAseq often account for only few percent of the total variance
• It performs poorly to separate cells in 0-inflated data types (because of it
non-linearity nature)
• Cell sizes and sequencing depth are usually captured in the top
principal components



# Dimensionality reduction with Umap atype of neighbourg graphs

Capture local structure rather than global structure approaches as PCA. Discriminate better among types.

UMAP is similar to t-SNE but faster!

UMAP: UniformManifold Approximation and Projection
• It is a NON-LINEAR graph-based method of
dimensionality reduction
• UMAP assumes that there is a manifold in the dataset, it
could also tend to cluster noise.
• Very efficient - O(n)
• Can be run from the top PCs (e.g.: PC1 to PC10)
• Can use any distance metrics!
• Can integrate between different data types (text,
numbers, classes)
• It is no longer completely stochastic as t-SNE
• Defines both LOCAL and GLOBAL distances
• Can be applied to newdata points


Including too many PCs usually does not affect much the result, while including too few PCs can affect the results very much.

UMAP: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space.
UMAP uses the previous PCA calculations

```{r Umap }
gbm <- Seurat::RunUMAP(gbm, dims = 1:5,n.neighbors = 50)
Seurat::DimPlot(gbm, reduction = "umap")
# and with coloured samples based on cell cycle
Seurat::DimPlot(gbm, reduction = "umap", group.by = "Phase")
```
# Clustering

The method implemented in Seurat first constructs a SNN graph based on the euclidean distance in PCA space, and refine the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset.

To cluster the cells, Seurat next implements modularity optimization techniques such as the Louvain algorithm (default) or SLM [SLM, Blondel et al., Journal of Statistical Mechanics], to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.

```{r clustering }
gbm <- Seurat::FindNeighbors(gbm, dims = 1:25)
# determine different cluster parameters from 0.1 to 0.8
gbm <- Seurat::FindClusters(gbm, resolution = seq(0.1, 0.8, by=0.1))
#Cluster id of each cell is added to the metadata object, as a new column for each resolution tested:
head(gbm@meta.data)
# we can view how clusters subdivise at increased resolution
clustree::clustree(gbm@meta.data[,grep("RNA_snn_res", colnames(gbm@meta.data))],
                   prefix = "RNA_snn_res.")
# can view the UMAP with the clustering info
Seurat::DimPlot(gbm, group.by = "RNA_snn_res.0.1")
# we saw that probably clustering at a resolution of 0.2 gave the most sensible results. Let’s therefore set the default identity of each cell based on this clustering:
gbm <- Seurat::SetIdent(gbm, value = gbm$RNA_snn_res.0.2)
```

# Cell annotation

From now on, grouping (e.g. for plotting) is done by the active identity (set at @active.ident) by default


Based on the UMAP we have generated, we can visualize expression for a gene in each cluster:
```{r expressionclusters }
Seurat::FeaturePlot(gbm, "PMP2")
```
Based on expression of sets of genes you can do a manual cell type annotation. If you know the marker genes for some cell types, you can check whether they are up-regulated in one or the other cluster. Here we have some marker genes for two different cell types:

```{r manually annotate genes }
immune_genes<-c("GZMA", "CD3E", "CD3D")
microglia_genes<-c("CCL4", "CCL3", "P2RY12", "C1QB", "CSF1ER", "CY3CR1")
#Let’s have a look at the expression of the three immune genes:
Seurat::FeaturePlot(gbm, immune_genes, ncol=2)
```

These cells are almost all in cluster 6. Which becomes clearer when looking at the violin plot:

```{r violin immune genes }
Seurat::VlnPlot(gbm,
                features = immune_genes,
                ncol = 2)
```

```{r microglia genes }
Seurat::FeaturePlot(gbm, microglia_genes, ncol=2)
# which correspond mainly to cluster 1 and 4
Seurat::VlnPlot(gbm,
                features = microglia_genes,
                ncol = 2)
#We can also automate this with the function AddModuleScore. For each cell, an expression score for a group of genes is calcuated and represented in the meta.data as column "immune genes1"

gbm <- Seurat::AddModuleScore(gbm,
                              features = list(immune_genes),
                              name = "immune_genes")
Seurat::FeaturePlot(gbm, "immune_genes1")
Seurat::VlnPlot(gbm,
                "immune_genes1") # please note that the column is named immune_genes1
```

# Cell type annotation using SingleR

To do a fully automated annoation, we need a reference dataset of primary cells. Any reference could be used. The package scRNAseq in Bioconductor includes several scRNAseq datasets that can be used as reference to SingleR. One could also use a reference made of bulk RNA seq data. Here we are using the Human Primary Cell Atlas dataset from celldex. Check out what’s in there:

```{r global annotation singleR }
hpca.se <- celldex::HumanPrimaryCellAtlasData()
class(hpca.se)
table(hpca.se$label.main)

#Now SingleR compares our normalized count data to a reference set, and finds the most probable annation:

gbm_SingleR <- SingleR::SingleR(test = Seurat::GetAssayData(gbm, slot = "data"),
                                ref = hpca.se,
                                labels = hpca.se$label.main)
head(gbm_SingleR)
```



In order to visualize it in our UMAP, we have to add the annotation to gbm@meta.data:
```{r Viz global annotation singleR }
gbm$SingleR_annot <- gbm_SingleR$labels
# and vizualize UMAP
Seurat::DimPlot(gbm, group.by = "SingleR_annot", label = T, repel = T)

#We can have a look at the mean module score for each annotation like this:

mean_scores <- tapply(gbm$immune_genes1, gbm$SingleR_annot, mean)
mean_scores[order(mean_scores, decreasing = TRUE)[1:6]]


```

Showing that T-cells and NK-cells have a high module score based on our set of immune genes, which makes sense.

Of course, it was also already clear from the UMAP plots that cluster 6 (the cluster with the high module score for the immune genes) contained the T-cells and NK-cells.

## ! A recent preprint suggest that t-SNE and UMAP do not preserve local or global structure & are misleading. They're also arbitrary

link to bioRxiv : https://t.co/XkAOTKlOcs?amp=1
link to twitter Thread : https://twitter.com/lpachter/status/1431325969411821572

you can't make claims about datasets being the same or different based on a t-SNE or UMAP alone.

Picasso tool could be a solution to overcome this. showing how cell cluster but making any nice plot, like an elephant o a gorilla!




# Integration 

    This chapter uses the pancreas dataset, which is described in this paper : https://www.biorxiv.org/content/10.1101/460147v1

Single cell transcriptomics (scRNA-seq) has transformed our ability to discover and annotate cell types and states, but deep biological understanding requires more than a taxonomic listing of clusters. As new methods arise to measure distinct cellular modalities, including high-dimensional immunophenotypes, chromatin accessibility, and spatial positioning, a key analytical challenge is to integrate these datasets into a harmonized atlas that can be used to better understand cellular identity and function. 

The gbm dataset does not contain any samples, treatments or methods to integrate. Therefore for these exercises we will use a different dataset that is described in Comprehensive Integration of Single CellData. It is a dataset comprising of four different single cell experiment performed by using four different methods.

```{r Import Pancreas data }
pancreas.data <- readRDS(file = "C://Users/imateusg/Documents/WW_courses/02_SingleCELL_SIB2021/single_cell_course/data/pancreas_dataset/pancreas_expression_matrix.rds")
metadata <- readRDS(file = "C://Users/imateusg/Documents/WW_courses/02_SingleCELL_SIB2021/single_cell_course/data/pancreas_dataset/pancreas_metadata.rds")

pancreas <- Seurat::CreateSeuratObject(pancreas.data, meta.data = metadata)
head(pancreas@meta.data)
table(pancreas@meta.data$celltype)
```
The dataset contain ifo about tech (sequencing platform) and celltype (13 different types). The cell types where previously defined, with the use of antibodies???

Visualize the data, so first: normalize, find features as , scale data, run PCA and UMAP.
```{r Pancreas analysis }
pancreas <- Seurat::NormalizeData(pancreas)
pancreas <- Seurat::FindVariableFeatures(pancreas, selection.method = "vst", nfeatures = 2000)
pancreas <- Seurat::ScaleData(pancreas)
pancreas <- Seurat::RunPCA(pancreas, npcs = 30)
pancreas <- Seurat::RunUMAP(pancreas, reduction = "pca", dims = 1:30)

#and plot the UMAP based on technology
Seurat::DimPlot(pancreas, reduction = "umap", group.by = "tech")

# part of variance explained by the 2 variables

ctsP <- Seurat::GetAssayData(pancreas, slot = "counts")
pancreas_sce <- SingleCellExperiment::SingleCellExperiment(
  assays = list(counts = ctsP),
  colData = pancreas@meta.data,
  rowData = rownames(pancreas) )

pancreas_sce <- scater::logNormCounts(pancreas_sce)  # alternative to Seurat's normalization here using scater

vars2 <- scater::getVarianceExplained(pancreas_sce,
                             variables = c("tech","celltype") )
head(vars2) # show how each variable is  explained for each gene 
scater::plotExplanatoryVariables(vars2)

```
We observe that there are bias related to thech and celltype variable.

IF we plot the umap in fonction of the celltype
```{r Pancreas analysiscelltype }
Seurat::DimPlot(pancreas, reduction = "umap", group.by = "celltype")
```

We observe that the celltype describes well the dataset. So we need to integrate he tech type into account as an explanatory variable

To perform the integration, we split the combined object into a list, with each dataset as an element. We perform standard preprocessing (log-normalization), and identify variable features individually for each dataset based on a variance stabilizing transformation ("vst").

So we split the tech dataset and normalize it independantly for each tech type
```{r Pancreas integration_split tech data }
pancreas.list <- Seurat::SplitObject(pancreas, split.by = "tech")

for (i in 1:length(pancreas.list)) {
    pancreas.list[[i]] <- Seurat::NormalizeData(pancreas.list[[i]])
    pancreas.list[[i]] <- Seurat::FindVariableFeatures(pancreas.list[[i]], selection.method = "vst", nfeatures = 2000,
        verbose = FALSE)
}
```


And lets proceed with the integration that is made in two steps

```{r Pancreas integration_prepareAnchors Integrate }
pancreas.anchors <- Seurat::FindIntegrationAnchors(object.list = pancreas.list, dims = 1:30)
pancreas.integrated <- Seurat::IntegrateData(anchorset = pancreas.anchors, dims = 1:30)
```

After running IntegrateData, the Seurat object will contain an additional element of class Assay with the integrated (or ‘batch-corrected’) expression matrix. This new Assay is called integrated, and exists next to the already existing RNA element with class Assay.

! Attention.Use the Assay integrated only for clustering and visualisation. It will give unexpected results during e.g. differential gene expression analysis. Therefore, use the RNA element for other analyses

We dont need to re-run FindVariableFeatures, these were automatically set by calling IntegrateData

We switch the default assay to the integrated one (instead of RNA)
```{r Pancreas switch assay }

Seurat::DefaultAssay(pancreas.integrated) <- "integrated"
```
In order to redo the clustering, scale the integrated data, run the PCA and the UMAP again (using the function ScaleData, RunPCA and RunUMAP). After that, generate the same two UMAP plots (grouped by tech and by celltype). Did the integration perform well?


Performing the scaling, PCA and UMAP:
```{r Pancreas integrated umap }

pancreas.integrated <- Seurat::ScaleData(pancreas.integrated)
pancreas.integrated <- Seurat::RunPCA(pancreas.integrated, npcs = 30)
pancreas.integrated <- Seurat::RunUMAP(pancreas.integrated, reduction = "pca", dims = 1:30)

#Plotting the UMAP:

Seurat::DimPlot(pancreas.integrated, reduction = "umap", group.by = "tech")
Seurat::DimPlot(pancreas.integrated, reduction = "umap", group.by = "celltype", label = TRUE, repel = TRUE)
```